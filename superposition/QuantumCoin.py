'''
Script: quCoin.py
Author: thuulk
Date: 2025
Description: Simulating a quantum coin with a qubit a Hadamard gate
'''
# A classical bit can only hold boolean values (0 or 1).
# A qubit has the property of superposition, meaning it can be in both states (0 and 1) at the same time.
# |ψ⟩ = α|0⟩ + β|1⟩; where α and β are complex amplitudes representing the probabilities of measuring the qubit
# in states |0⟩ and |1⟩ respectively.
#
# α := amplitude for the |0⟩ state
# β := amplitude for the |1⟩ state
#
# prob(0) = |α|^2
# prob(1) = |β|^2
#
# The sum of the squares of the amplitudes must be equal to 1: |α|^2 + |β|^2 = 1.
#
# A qubit is initialized in the state |0⟩ = |1|
#                                          |0|
#
# The Hadamard gate, denoted by H, is a fundamental operation in quantum computing that transforms a qubit
# from a basis state into an equal superposition of both basis states.
# H = 1/sqrt(2) * | 1  1 |
#                 | 1 -1 |
#
# Applying the Hadamard gate to the |0⟩ state, we obtain:
# H|0⟩ = 1/sqrt(2) * (|0⟩ + |1⟩) -> α = β = 1/sqrt(2)
#
# This means that after applying the Hadamard gate, the qubit is in an equal superposition of states |0⟩ and |1⟩,
# with a 50% probability of measuring it in either state.
# In the simulation, complex amplitudes are not shown; instead, only the resulting measurement probabilities
# after applying the Hadamard gate are observed.



from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator


class QuantumCoin:


    def __init__(self, nQubits=1, mBits=1):    

        """
        Constructor
        """
        
        self.nQubits = nQubits             # attributes
        self.mBits = mBits
        self.qc = QuantumCircuit(nQubits,mBits) # QuantumCircuit(nQubits, mBits); let n be the number of qubits and m the number of bits
                                                # the classic bit is to storage the measurment of the complex amplitudes.
                                                # qc stands for QuantumCircuit, not QuantumCoin
        self.simulator = AerSimulator()


    def flip_the_coin(self, nFlips): 

        """
        Flips the quantum coin nFlips times.
        Returns a dictionary with counts of '0' and '1'.
        """

        try :
            i = int(input("Insert the index of the qubit to meassure (int): "))
            j = int(input("Insert the index of the bit to storage the meassure (int): "))
        

        except ValueError:
            print("The index must be an int")
            return None
        

        if i < 0 or i >= self.nQubits or j < 0 or j >= self.mBits:
            print("Indexes must be greater then 0 and tops j = mBits - 1 and i = nQubits - 1")
            return None

        self.qc = QuantumCircuit(self.nQubits, self.mBits)              # Reinitializing quantum circuit
        self.qc.h(0)                                                    # H|0⟩
        self.qc.measure(i, j)                                           # measuring qubit i and storaging it in bit j
        simulations = self.simulator.run(self.qc, shots=nFlips)         # running the simulation given the circuit and the number of iterations
        logs = simulations.result()                                     # an autogenerated log from the simulator significative data 
        count = logs.get_counts(self.qc)                                # querying the qubit state and its count
        return count                    
